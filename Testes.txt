> Pirâmide de Testes:
	
lento		           ---Manual---                       alto custo
		      -----End-to-End-----
		  -----------Integração-----------
rapido	     --------------Testes Unitários--------------    baixo custo

> Significa que os Testes unitários (base) são mais rápidos de serem desenvolvidos e testados, e são menos custosos.
	> Os testes unitários baseiam-se em testar a menor unidade do código, do software. Em POO seria, por exemplo, uma função de uma Classe.

> Os testes de integração baseiam-se em testar a integração de unidades do sistema, por exemplo, o código conectando com banco de dados, serviços, entre outros. São mais custosos, lentos e complexos de serem desenvolvidos, se comparados aos Unitários.
Realizar testes de integração não é testar a lógica das unidades, mas testar como as diferentes unidades interagem entre si.

> End-to-End (E2E / ponta-a-ponta) são os testes que testam o sistema como um todo, geralmente incluem interfaces e buscam testar as funcionalidades do sistema, como se um usuario estivesse utilizando o sistema. São mais custosos, lentos e complexos se comparados ao de integração e unitario.
> Por fim, os testes manuais consistem em inserir os dados manualmente. Por exemplo, login de um usario, o teste consistiria em o testador inserir manualmente os dados e verificar o funcionamento do software.

> Conclusão: Devemos sempre buscar ter mais testes unitarios, testes de integração quando necessario, ou seja, quando não há necessidade de testar o sistema todo (e2e) mas também os teste unitarios nao conseguem cobrir a necessidade. Por fim, devemos ter poucos testes e2e, devido a sua alta complexidade, lentidão e alto custo, sendo utilizados somente em ocasioes especificas e necessarias.

-----

> Teste de aceite, como o teste do sistema (e2e), geralmente se concentra no comportamento e na capacidade de todo um sistema ou produto. Ele pode produzir informações para avaliar a situação do sistema para implantação e uso pelo cliente (usuario final). O teste de aceite também pode satisfazer requisitos, padrões legais ou regulatórios. 
- Formas comuns de testes de aceite incluem o seguinte:
	> Teste de aceite do usuario (UAT)
		> Consiste em colocar o sistema em um ambiente controlado para que o usuario faça um "TestDrive".
	> Teste de aceite operacional (OAT)
		> Focado na equipe de administração do sistema. Realizado em ambiente controlado, podem incluir testes como backup e restauração, instalação, recuperação de desastres, gerenciamento de usuários, tarefas de manutenção, vulnerabilidade, segurança e teste de performance.
	> Teste de aceite contrattual e regulatório:
		> Realizado com base nos critérios de aceite de um contrato para desenvolver softwares específicos

> Teste Alfa:
	> Semelhante ao teste de aceite, porém é realizado de uma forma não planejada, disponibilizando o sistema dentro da infraestrutura da empresa que desenvolveu o produto e para um pequeno grupo de pessoas. Essas pessoas geralmente são membros da organização e também o cliente. O objetivo é que esse grupo de pessoas deem feedbacks sobre a situação atual em que o sistema se encontra.
> Teste Beta:
	> Realizado de forma não planejada e executado por um grande número de pessoas desconhecidas. Sistema é executado na infraestrutura dessas pessoas que não possuem nenhuma relação com a equipe ou empresa desenvolvedora. Utilizado como forma de aceitação externa possibilitando avaliar o feedback do mercado.

> Tipos de teste:
	> Grupo de atividades de teste destinado a testar características específicas de um sistema de software, ou parte de um sistema, com base em objetivos de teste específicos:

> Teste funcional
	> Envolve testes que avaliam as funções que o sistema deve executar. As funções são "o que" o sistema deve fazer.

> Teste não funcional
	> Avaliam as características de sistemas e de softwares, como usabilidade, eficiência de performance ou segurança. O Teste não funcional é o teste de "quaõ bem" o sistema deve se comportar.

> Teste caixa-branca
	> É derivado de testes com base na estrutura interna ou na implementação do sistema. A estrutura interna pode incluir código, arquitetura, fluxos de trabalho e fluxos de dados dentro do sistema.

> Testes relacionados à mudança
	> Quando são feitas alterações (independente do motivo) deve-se testar para confirmar se as alterações corrigiram o defeito ou implementaram a funcionalidade corretamente e, principalmente, não causaram consequências adversas imprevistas. Para isso é utilizado o Teste de confirmação ( depois que um defeito é corrigido, o software pode ser testado com todos os casos de teste que falharam devido ao defeito), e o Teste de regressão (o teste de regressão envolve a execução de testes para detectar esses efeitos colaterais indesejados)

> Podemos executar os testes de duas formas, MANUAL ou AUTOMATIZADA

> Teste manual
	> Significa testar um aplicativo manualmente por um ser humano. O Testador avalia o design, a funcionalidade e o desempenho do aplicativo verificando vários elementos. São recomendados quando se utilizam *testes exploratórios*, *teste de usabilidade* e *testes de aceite*. Útil quando não é possível (ou custoso e desnecessário) implementar o teste automatizado

> Teste automatizado
	> Significa desenvolver testes programados para serem executados automaticamente. Compara resultados reais com resultados esperados. Ajudam a saber se o software tem o desempenho esperado ou não. São executados com auxílio de ferramentas, scripts e softwares. São recomendados para realizar testes de regressão, testes de carga e testes de performance


> Teste de serviço
	> Nesta camada são executados todos os testes considerados a nível de serviço (nesta camada são executados alguns tipos de teste como API, Integração e Contrato).
- Tipos de testes nesta fase:

> Teste de API
	> Está entre a camada de Teste unitário e de User Interface (UI) e podem ser automatizados em paralelo com o desenvolvimento. Eles realizam a validação de múltiplos cenários e garantem que o conteúdo do Json de retorno esteja correto.

> Teste de Contrato
	> Em um contexto de services e microservices, os testes de contrato verificam a validade dos mocks que representam a simulação das comunicações entre serviço e consumidor. Tem a finalidade de validar se o contrato acordado foi ou não quebrado. A essência dos testes de contrato não é afirmar a funcionalidade. O que queremos alcançar é a verificação da semântica. Se o produtor e o consumidor podem se comunicar com sucesso no ambiente de produção.

> Teste de UI 
	> Nesta camada são executados os testes automatizados a nível de interface do usuário. Simula o comportamento do usuário no sistema. Os testes de alto nível (topo da pirâmide) é como uma segunda linha de defesa de teste. Se você tiver uma falha em um teste de alto nível, não apenas você tem um bug em seu código funcional, você também tem um teste de unidade que está faltando ou está incorreto. Assim, se aconselha que antes de corrigir um bug exposto por um teste de alto nível, você deve replicar o bug com um teste de unidade.

> Resumindo:
	> Fases de Teste
		> Teste unitário
		> Teste de integração
		> Teste de sistema (e2e)
		> Teste de aceitação
	> Tipos de Teste
		> Teste funcional
		> Teste nao funcional
		> Teste caixa-branca
	> Forma de execução
		> Teste manual
		> Teste automatizado


> Mock:
	> Objetos que utilizamods para "simular" interações de saída com dependencias externas ao nosso teste. Essas interações de saída são chamadas que o nosso teste realiza para mudar o seu estado.
	> Com mocks podemos controlar e inspecionar as chamadas para essa falsa dependência. O Mock simula seu comportamento verificando se um ou mais métodos foram ou não chamados, a ordem de chamadas destes métodos, se esses métodos foram chamados com os argumentos certos e quantas vezes foram chamados.
	> Usar mocks para:
		> Testar se um ou mais métodos de uma dependência externa foi chamado corretamente;
		> Testar quantas vezes esses métodos foram chamados
		> Testar se esses métodos foram chamados com os parâmetros corretos
	> Não usar mocks para:
		> Testar valores retornados por uma função
		> Testar comportamentos de uma função
	
> Stub:
	> Objetos que usamos para simular interações de chegada de alguma dependência externa ao SUT (System under test). Diferente do mock, stubs são objetos com respostas prontas para serem usados no nosso teste. Eles não sabem responder quantas vezes um método de uma dependência externa foi ou não chamado e quais parâmetros foram usados, apenas trazem respostas prontas.
	> Usar stubs para:
		> Testar retornos de uma dependência externa
		> Testar o comportamento do nosso SUT frente aos diferentes retornos da API. Por exemplo, retornos de sucesso, falhas ou exceções;











